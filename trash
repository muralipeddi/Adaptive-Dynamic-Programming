# ~/Desktop/f1tenth_ws/src/adp_controller/scripts/utils/data_collector.py

#!/usr/bin/env python3

import rclpy
from rclpy.node import Node

from nav_msgs.msg import Odometry
from std_msgs.msg import Float32MultiArray
from ackermann_msgs.msg import AckermannDriveStamped

import numpy as np
import os

class ADPDataCollector(Node):
    def __init__(self):
        super().__init__('data_collector')

        # Buffers
        self.x_buffer = []
        self.u_buffer = []
        self.x_next_buffer = []
        self.vx_buffer = []
        self.kappa_buffer = []

        self.last_x = None
        self.last_u = None

        # Subscriptions
        self.create_subscription(Float32MultiArray, '/frenet_errors', self.frenet_callback, 10)
        self.create_subscription(Odometry, '/ego_racecar/odom', self.odom_callback, 10)
        self.create_subscription(AckermannDriveStamped, '/drive', self.drive_callback, 10)

        self.get_logger().info("Data Collector Initialized (Press Ctrl+C to stop and choose whether to save)")

    def frenet_callback(self, msg):
        # ey, dot_ey, epsi, dot_epsi, kappa
        self.current_frenet = msg.data

    def drive_callback(self, msg):
        # Store delta, speed
        self.last_u = [msg.drive.steering_angle, msg.drive.speed]

    def odom_callback(self, msg):
        if not hasattr(self, 'current_frenet') or self.last_u is None:
            return

        Vx = msg.twist.twist.linear.x
        kappa = self.current_frenet[4]

        # Construct state: [ey, dot_ey, epsi, dot_epsi, s, Vx]
        ey, dot_ey, epsi, dot_epsi = self.current_frenet[:4]
        s = 0.0  # Longitudinal progress can be added later if needed
        x = [ey, dot_ey, epsi, dot_epsi, s, Vx]

        if self.last_x is not None:
            # Save transition (x, u, x_next)
            self.x_buffer.append(self.last_x)
            self.u_buffer.append(self.last_u)
            self.x_next_buffer.append(x)
            self.vx_buffer.append(Vx)
            self.kappa_buffer.append(kappa)

            if len(self.x_buffer) % 500 == 0:
                self.get_logger().info(f"Collected {len(self.x_buffer)} new samples...")

        self.last_x = x

    def save_data(self):
        save_path = os.path.join(os.path.dirname(__file__), "adp_dataset.npz")

        if os.path.exists(save_path):
            old = np.load(save_path)
            self.get_logger().info("Appending to existing dataset...")
            x_all = np.concatenate([old['x'], self.x_buffer])
            u_all = np.concatenate([old['u'], self.u_buffer])
            x_next_all = np.concatenate([old['x_next'], self.x_next_buffer])
            vx_all = np.concatenate([old['Vx'], self.vx_buffer])
            kappa_all = np.concatenate([old['kappa'], self.kappa_buffer])
        else:
            x_all = np.array(self.x_buffer)
            u_all = np.array(self.u_buffer)
            x_next_all = np.array(self.x_next_buffer)
            vx_all = np.array(self.vx_buffer)
            kappa_all = np.array(self.kappa_buffer)

        np.savez(save_path,
                 x=x_all,
                 u=u_all,
                 x_next=x_next_all,
                 Vx=vx_all,
                 kappa=kappa_all)
        self.get_logger().info(f"Saved total of {x_all.shape[0]} samples to {save_path}")

    def destroy_node(self):
        if len(self.x_buffer) == 0:
            self.get_logger().info("No data collected. Skipping save.")
        else:
            try:
                answer = input("\nDo you want to save the collected data? [y/N]: ").strip().lower()
                if answer == 'y':
                    self.save_data()
                else:
                    self.get_logger().info("Data was not saved.")
            except Exception as e:
                self.get_logger().error(f"Error during save prompt: {e}")
        super().destroy_node()


def main(args=None):
    rclpy.init(args=args)
    node = ADPDataCollector()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        node.get_logger().info("Keyboard interrupt received. Prompting for save...")
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
