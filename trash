#!/usr/bin/env python3

import numpy as np
import os

# === Load data ===
data_dir = os.path.expanduser("~/Desktop/f1tenth_ws/src/adp_controller/data")
x = np.load(os.path.join(data_dir, "x.npy"))         # shape: (N, 4)
u = np.load(os.path.join(data_dir, "u.npy"))         # shape: (N, 1)
x_next = np.load(os.path.join(data_dir, "x_next.npy"))  # shape: (N, 4)

N, n = x.shape

# === Cost matrices (same as version 1 LQR) ===
Q = np.diag([5.0, 0.5, 5.0, 0.5])
R = np.array([[1.0]])

# === Build least squares system: A * p_vec = b ===
def outer_sym(v):
    """Flatten symmetric outer product v.T @ v"""
    return np.array([
        v[0]**2, v[0]*v[1], v[0]*v[2], v[0]*v[3],
                    v[1]**2, v[1]*v[2], v[1]*v[3],
                                v[2]**2, v[2]*v[3],
                                            v[3]**2
    ])

A_ls = []
b_ls = []

for i in range(N):
    x_t = x[i]
    x_tp1 = x_next[i]
    u_t = u[i]

    phi = outer_sym(x_tp1) - outer_sym(x_t)
    cost = x_t @ Q @ x_t + u_t @ R @ u_t

    A_ls.append(phi)
    b_ls.append(-cost[0])  # scalar

A_ls = np.array(A_ls)  # shape: (N, 10)
b_ls = np.array(b_ls)  # shape: (N,)

# === Solve least squares ===
p_vec, _, _, _ = np.linalg.lstsq(A_ls, b_ls, rcond=None)  # 10 values

# === Reconstruct symmetric matrix P ===
P = np.array([
    [p_vec[0], p_vec[1], p_vec[2], p_vec[3]],
    [p_vec[1], p_vec[4], p_vec[5], p_vec[6]],
    [p_vec[2], p_vec[5], p_vec[7], p_vec[8]],
    [p_vec[3], p_vec[6], p_vec[8], p_vec[9]],
])

print("[âœ…] Learned value function matrix P:")
print(P)

# === Save P to file ===
np.save(os.path.join(data_dir, "P_learned.npy"), P)
print("[ðŸ’¾] Saved to:", os.path.join(data_dir, "P_learned.npy"))
