# ~/Desktop/f1tenth_ws/src/adp_controller/adp_controller/adp_raceline_runner.py

#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from std_msgs.msg import Float32MultiArray
from ackermann_msgs.msg import AckermannDriveStamped
from nav_msgs.msg import Odometry
import numpy as np
import argparse
import sys

class ADPRacelineRunner(Node):
    def __init__(self, vmax):
        super().__init__('adp_raceline_runner')
        self.K = np.array([-1.5, -0.2, -2.0, -0.3])  # general-purpose gain
        self.vmax = vmax  # user-defined max speed
        self.kappa = 0.0
        self.frenet_errors = None

        # Subscribers
        self.create_subscription(Float32MultiArray, '/frenet_errors', self.frenet_callback, 10)
        self.create_subscription(Odometry, '/ego_racecar/odom', self.odom_callback, 10)

        # Publisher
        self.drive_pub = self.create_publisher(AckermannDriveStamped, '/drive', 10)

        # Timer for control loop
        self.create_timer(0.02, self.control_loop)
        self.get_logger().info(f"ADP Raceline Runner initialized with vmax = {self.vmax:.2f} m/s")

    def frenet_callback(self, msg):
        self.frenet_errors = msg.data
        self.kappa = self.frenet_errors[4] if len(msg.data) >= 5 else 0.0

    def odom_callback(self, msg):
        pass  # Not used, but we can store Vx here if needed later

    def control_loop(self):
        if self.frenet_errors is None:
            return

        e_y, dot_e_y, e_psi, dot_e_psi = self.frenet_errors[:4]
        x = np.array([e_y, dot_e_y, e_psi, dot_e_psi])

        # Steering control
        delta = float(-np.dot(self.K, x))
        delta = np.clip(delta, -0.4189, 0.4189)

        # Curvature-based speed modulation
        kappa_abs = abs(self.kappa)
        speed = self.vmax * np.exp(-4.0 * kappa_abs)  # tuneable decay rate
        speed = np.clip(speed, 0.5, self.vmax)

        # Publish command
        msg = AckermannDriveStamped()
        msg.drive.steering_angle = delta
        msg.drive.speed = speed
        self.drive_pub.publish(msg)


def main(args=None):
    rclpy.init(args=args)

    parser = argparse.ArgumentParser()
    parser.add_argument('--vmax', type=float, default=5.0, help='Max speed for straight sections')
    parsed_args, _ = parser.parse_known_args()

    node = ADPRacelineRunner(vmax=parsed_args.vmax)
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        node.get_logger().info("Shutting down raceline runner.")
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
