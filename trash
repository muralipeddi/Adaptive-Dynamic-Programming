#!/usr/bin/env python3

import rclpy
from rclpy.node import Node

import numpy as np
import os
from scipy.linalg import solve_discrete_are

class RiccatiSolver(Node):
    def __init__(self):
        super().__init__('riccati_solver')

        # Load data
        data_dir = os.path.join(os.path.expanduser("~"), "Desktop/f1tenth_ws/src/adp_controller/data")
        self.x = np.load(os.path.join(data_dir, "x.npy"))
        self.u = np.load(os.path.join(data_dir, "u.npy"))
        self.x_next = np.load(os.path.join(data_dir, "x_next.npy"))

        self.get_logger().info(f"Loaded data shapes: x={self.x.shape}, u={self.u.shape}, x_next={self.x_next.shape}")

        self.compute_dynamics_and_solve_riccati()

    def compute_dynamics_and_solve_riccati(self):
        # Stack [x_t, u_t] -> [X | U]
        XU = np.hstack((self.x, self.u))  # shape: (N, 5)
        Y = self.x_next  # shape: (N, 4)

        # Least-squares fit: Y = [A B] * [X U]
        AB, _, _, _ = np.linalg.lstsq(XU, Y, rcond=None)  # AB shape: (5, 4)
        AB = AB.T  # shape: (4, 5)

        A = AB[:, :4]  # shape: (4, 4)
        B = AB[:, 4:]  # shape: (4, 1)

        self.get_logger().info(f"A matrix:\n{A}")
        self.get_logger().info(f"B matrix:\n{B}")

        # Cost matrices (tune as needed)
        Q = np.diag([1.0, 1.0, 0.1, 0.1])   # Penalize lateral and heading errors more
        R = np.array([[0.5]])              # Penalize steering effort

        # Solve DARE
        P = solve_discrete_are(A, B, Q, R)
        K = np.linalg.inv(R + B.T @ P @ B) @ (B.T @ P @ A)

        self.get_logger().info(f"Feedback gain K:\n{K}")

        # Save gain to disk
        np.save(os.path.join(os.path.expanduser("~"), "Desktop/f1tenth_ws/src/adp_controller/data/K.npy"), K)
        self.get_logger().info("Saved K to disk successfully.")

def main(args=None):
    rclpy.init(args=args)
    node = RiccatiSolver()
    node.destroy_node()
    rclpy.shutdown()
